#!/bin/python3   ---- shebang
import hashlib    # provides hashing algorithms like MDS, SHA-1 to create unique fingerprints for files
import os    #handles fie and directory operations

# Sample malicious signatures (hashes of malicious content)
MALICIOUS_HASHES = {
    "e99a18c428cb38d5f260853678922e03",  # MD5 hash of "malicious_code"
    "098f6bcd4621d373cade4e832627b4f6"   # MD5 hash of "test"
}
'''
MALICIOUS_HASHES = {
    "e99a18c428cb38d5f260853678922e03",  # MD5 hash of "malicious_code"
    "098f6bcd4621d373cade4e832627b4f6"   # MD5 hash of "test"
}
this is a set of known malicious file hashes
Each hash corresponds to a file unique signature. 
if the file matches one of these hashes, it is flagged malicious
'''

def calculate_md5(file_path):
    """Calculate the MD5 hash of a file."""
    hasher = hashlib.md5()  # Creates MD5 hash of a file
    with open(file_path, 'rb') as f:    # open(file_path, 'rb') opens binary mode 'rb' to read raw data
        while chunk := f.read(4096):  #f.read(4096) reads file in chunks of 4kb to handle files efficiently
            hasher.update(chunk) #update the hash object with current
    return hasher.hexdigest()  #returns MD5  hash as a hexadecimal string

def scan_file(file_path):
    """Scan a file for malicious signatures."""
    print(f"Scanning {file_path}...")
    file_hash = calculate_md5(file_path)   #Generates the md5 hash of the file
    if file_hash in MALICIOUS_HASHES:   #Checks if the hash matches a known malicious hash
        return f"Malicious file detected! Hash: {file_hash}"   #REturns whether the file is clean or malicious
    return "File is clean."

def scan_directory(directory):
    """Scan all files in a directory."""
    for root, _, files in os.walk(directory):  #Walk through all subdirectories and files in the given directory
        for file in files:
            file_path = os.path.join(root, file)
            result = scan_file(file_path)  #scan each file in the directory
            print(result)  #displays the scan result for each file

if __name__ == "__main__":  #ensures the script runs only when executed directly not when imported
    directory_to_scan = input("Enter the directory to scan: ").strip()  #Prompts the user to input the directory path
    if os.path.isdir(directory_to_scan):  #Checks if the input is a valid directory
        scan_directory(directory_to_scan)  #SCan the specified directory
    else:
        print("Invalid directory!")    #alerts user directory does not exist

'''
An MD5 hash is a fixed-length string (32 hexadecimal characters) that 
serves as a unique "fingerprint" for a piece of data, such as a file or a 
string. It is generated by the MD5 (Message-Digest Algorithm 5), which is a 
widely used cryptographic hash function.

### **Key Characteristics of MD5:**
1. **Deterministic**: For a given input, the MD5 algorithm will always produce the same hash.
   - Example: Hashing the string `"hello"` will always result in `5d41402abc4b2a76b9719d911017c592`.
   
2. **Fixed Size**: Regardless of the input size, the output is always 128 bits (or 32 characters in hexadecimal).
   - Example: A small file and a large file will each produce a 32-character MD5 hash.

3. **One-Way Function**: It’s computationally infeasible to reverse-engineer the original data from the hash.

4. **Collision Possibility**: Different inputs should ideally produce different hashes. However, MD5 is no longer considered cryptographically secure because researchers have found ways to create **collisions** (different inputs producing the same hash).

---

### **How MD5 Hashing Works**
1. **Input**: The MD5 function takes any data (text, file, etc.) as input.
2. **Process**: The algorithm performs mathematical operations on the data to scramble it.
3. **Output**: A fixed-length hash is produced.

---

### **Example: Hashing a String**
Here’s how the string `"hello"` is hashed using MD5:

- Input: `"hello"`
- MD5 Hash: `5d41402abc4b2a76b9719d911017c592`

---

### **Common Uses of MD5**
1. **File Verification**: Ensure that a file has not been tampered with during transfer by comparing its hash with a known value.
2. **Password Storage** (deprecated): Previously used to store hashed passwords in databases. However, this is insecure and no longer recommended.
3. **Malware Detection**: Compare the MD5 hash of files against a database of known malicious hashes.
4. **Digital Signatures**: Generate hashes to verify the integrity of data.

---

### **Why MD5 is Insecure**
- **Collisions**: Researchers have found ways to create two different inputs that result in the same hash.
- **Lack of Salt**: Without adding randomness (like a "salt"), identical data will always produce the same hash, making it vulnerable to attacks like rainbow tables.

---

### **Alternatives to MD5**
For secure hashing, modern algorithms like **SHA-256** or **SHA-3** are recommended.

Would you like an example of how MD5 works in Python, or should we explore alternatives like SHA-256?

'''
